#!/usr/bin/env swipl
% vim: set filetype=prolog: ts=2 sw=2 sts=2 expandtab:cindent:formatoptions+=cro %

:- dynamic fact/3, used/3. % can be retracted/asserted at runtime

:- op(802, xfx,  if).
:- op(801, xfx,  then).
:- op(800, xfy,  or).
:- op(799, xfy,  and).
:- op(798,  fy,  not).
:- op(797, xfy,  had).
:- op(797, xfy,  has).
:- op(796, xfx,  in).

term_expansion(Meta if If then Then, Expanded) :-
   xpand(Meta if If then Then, Expanded).

xpand( Meta if If then Then, 
       ifThen(Group, Id, L)) :-
   vars(Then, Vars ),
   once(size(If, 0,Size)),
   meta(Meta, [id       = Id 
              ,(if)     = If
              ,vars     = Vars
              ,size     = Size 
              ,(then)   = Then
              ,group    = all
              ,priority = 1 
               ], L).

vars(X,L) :-
  term_variables(X,L0),
  sort(L0,L).

meta(X and Y)      --> meta(X), meta(Y).
meta(rule=Id)      --> swap(id=Id).
meta(group=Id)     --> swap(group=Id).
meta(priority=Id)  --> swap(priority=Id).

size(X and Y)      --> size(X), size(Y).
size(X or  Y)      --> size(X), size(Y).
size1(not X)       --> size(X).
size(_ had Y)      --> size(had(Y))).
size(had(X had Y)) --> size(had(X)), size(had(Y)).
size1(_)           --> inc.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

X and Y :- X,Y.
X or  _ :- X.
_ or  Y :- Y.
not X   :- \+ X.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "had"

X =Id had Y       :- fact(X,Id,Fs),  b4(Y,Fs).

b4(X had Y,Fs)    :- b4(X,Fs), b4(Y,Fs).
b4(X =  Y, Fs)    :- member(X=Y,Fs).
b4(X>=  Y, Fs)    :- b4(X=Z,Fs), Z>=Y.
b4(X >  Y, Fs)    :- b4(X=Z,Fs), Z> Y.
b4(X \= Y, Fs)    :- b4(X=Z,Fs), Z \= Y.
b4(X <  Y, Fs)    :- b4(X=Z,Fs), Z < Y.
b4(X =< Y, Fs)    :- b4(X=Z,Fs), Z =< Y.
b4(X in [H|T], Fs):- b4(X=Z,Fs), member(Z,[H|T]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "has"

X = Id has Y  :- 
   retract(fact(X,Id,Old)), 
   now(Y,Old,New), 
   asserta(fact(X,Id,New)). 

now(X has Y, Old,New) :-  now(X,Old,Tmp), now(Y,Tmp,New).
now(X = Y,  Old, New) :-  swap(X=Y,Old,New).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% inference engine

think :- reset0, reset, run(main), report.

report :- listing(fact).

reset0 ;-
  retractall(used(_,_,_)),
  retractall(fact(_,_,_)).

run(Group) :- 
   match(Group, Some),
   !,
   select(Some, One)
   act(One),
   run(Group).
run(_).

match(Group, L) :- findall(One,match1(Group,One),L).

match1(Group, [ (Priority, Size) = Then ]) :- 
  ifthen(Group,Id,L), 
  members([ id     = Id
          , at     = Priority
          , size   = Size,
          , (if)   = If
          , (then) = Then
          , var    = Vars 
          ], L),
  If,
  \+ used(Group, Id, Vars).

select(L, Then) :- sort(L, [ _ = Then | _ ]).

act(Then) :- Then.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% utils

less([],_,[]).
less([H|T],H,T).
less([H|T], H1, T) :- H \= H1, less(T,H1,T).

swap([],X,X).
swaps([X=Y|T]) -->  swap(X=Y), swap(T). 

swap(X=Y,L0,[X=Y|L] ) :- less(L0,X=_,L).

inc(X,Y) --> {Y is X + 1}.

members([], _).
members([H|T], L) :- member(H,L), members(T,L).

prints(L)  :- maplist(println,L).
println(X) :- print(X), nl.

allOps :- setof([P,A,X],current_op(P,A,X),L), prints(L).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% knowledge base

reset :-
  maplist(assert, 
     [ fact(emp, tim,       [dob=1990, job=cleaner, mother=president])
     , fact(emp, tony,      [dob=2002, job=cleaner, mother=president])
     , fact(emp, jane,      [job=president])
     , fact(job, cleaner,   [salary=10000])
     , fact(job, professor, [salary=30000])
     ]).

rule nepotism 
if   
     emp = E had job=J had mother in [president,chancellor] and
     job = J had salary =< 10000 and
     job = J2 had salary > 20000
then
     emp =E has job = J2.

rule promote for group at 1
     emp = E had job=J had mother in [president,chancellor] and
     job = J had salary =< 10000 and
     job = J2 had salary > 20000 and
     emp = E has dob > 2000
then
     emp =E has job = J2.
